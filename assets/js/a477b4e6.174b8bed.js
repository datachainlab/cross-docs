"use strict";(self.webpackChunkcross_docs=self.webpackChunkcross_docs||[]).push([[771],{7408:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return h},default:function(){return u}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],c={sidebar_position:3,id:"cross-chain-transaction"},s="Cross-chain Transaction",l={unversionedId:"architecture/cross-chain-transaction",id:"architecture/cross-chain-transaction",isDocsHomePage:!1,title:"Cross-chain Transaction",description:"Cross-chain Transaction is a distributed transaction executed between chains connected by IBC channel.",source:"@site/docs/03-architecture/03-cross-chain-transaction.md",sourceDirName:"03-architecture",slug:"/architecture/cross-chain-transaction",permalink:"/cross-docs/architecture/cross-chain-transaction",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"cross-chain-transaction"},sidebar:"tutorialSidebar",previous:{title:"Smart Contract",permalink:"/cross-docs/architecture/smart-contract"},next:{title:"Atomic commit protocol",permalink:"/cross-docs/architecture/atomic-commit-protocol"}},h=[{value:"Account",id:"account",children:[]},{value:"Initiate Transaction",id:"initiate-transaction",children:[]},{value:"Link",id:"link",children:[]},{value:"Authentication",id:"authentication",children:[{value:"SignTx",id:"signtx",children:[]},{value:"IBCSignTx",id:"ibcsigntx",children:[]},{value:"ExtSignTx",id:"extsigntx",children:[]}]},{value:"Transaction Execution",id:"transaction-execution",children:[]}],p={toc:h};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"cross-chain-transaction"},"Cross-chain Transaction"),(0,o.kt)("p",null,"Cross-chain Transaction is a distributed transaction executed between chains connected by IBC channel."),(0,o.kt)("p",null,"Cross Framework supports multiple atomic commit protocols and provides a state store that supports state commit, rollback, and concurrency control."),(0,o.kt)("p",null,"A chain that receives a request from a user verifies the contents of the request and sends a packet containing a contract invocation request to the specified chain to initiate a transaction. The chain that receives the user's request to initiate a transaction is called the initiator chain. Once the initiator chain receives a request, it processes the approval by each Account and then executes the Atomic commit flow according to the specified format."),(0,o.kt)("p",null,"For example, the initiator chain acts as a coordinator when executing Two-phase commit. First, the coordinator requests each participant chain to execute the contract function. Next, the coordinator gets the result of each call and decides whether or not to commit. After receiving the final decision, each participant chain commits or aborts the change."),(0,o.kt)("h2",{id:"account"},"Account"),(0,o.kt)("p",null,"An account is an entity that can send transactions to a blockchain. Typically, they are required to be uniquely identified within a given blockchain. Also, accounts in one chain are generally not interoperable with accounts in another chain because each blockchain has a different concept of account and a different representation scheme."),(0,o.kt)("p",null,"Cross-chain contract authentication can support a variety of authentication methods by allowing accounts on any blockchain to be used. In Cross Framework, an account consists of an ",(0,o.kt)("inlineCode",{parentName:"p"},"ID"),", which is an identifier of a user on each blockchain, and authentication information called ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthType"),". Thus, it is possible to identify accounts on different chains.\nSee ",(0,o.kt)("a",{parentName:"p",href:"#authentication"},"here")," for information on the authentication methods supported by Cross Framework."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},"message Account {\n  bytes id = 1;\n  AuthType auth_type = 2;\n}\n\nmessage AuthType {\n  AuthMode mode = 1;\n  google.protobuf.Any option = 2;\n}\n\nenum AuthMode {\n  AUTH_MODE_UNSPECIFIED = 0;\n  AUTH_MODE_LOCAL       = 1;\n  AUTH_MODE_CHANNEL     = 2;\n  AUTH_MODE_EXTENSION   = 3;\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"AuthMode")," is an identifier that refers to the authentication method, and ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," is the authentication information defined for each ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthMode"),". For ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTH_MODE_CHANNEL"),", the ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," contains the Channel information, and for ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTH_MODE_EXTENSION"),", the definition of the Extension protobuf.Any. Details of transaction authentication are described in ",(0,o.kt)("a",{parentName:"p",href:"#authentication"},"Authentication"),"."),(0,o.kt)("h2",{id:"initiate-transaction"},"Initiate Transaction"),(0,o.kt)("p",null,"A user creates a transaction defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgInitiateTx")," below and submits it to a chain to initiate a transaction. The chain to which ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgInitiateTx")," is submitted is called the initiator chain."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},"message MsgInitiateTx {\n  string chain_id = 1;\n  uint64 nonce    = 2;\n  cross.core.tx.CommitProtocol commit_protocol = 3;\n  repeated cross.core.initiator.ContractTransaction contract_transactions = 4;\n  repeated cross.core.auth.Account signers = 5;\n  ibc.core.client.v1.Height timeout_height = 6;\n  uint64 timeout_timestamp = 7;\n}\n\nmessage ContractTransaction {\n  google.protobuf.Any cross_chain_channel = 1;\n  repeated cross.core.auth.Account signers = 2;\n  bytes call_info = 3;\n  cross.core.tx.ReturnValue return_value = 4;\n  repeated Link links = 5;\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"MsgInitiateTx")," consists mainly of the following elements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"contract_transactions"),": an array of Contract Transactions that execute ",(0,o.kt)("a",{parentName:"li",href:"/cross-docs/architecture/overview#contract-module"},"Contract Module")," on each chain"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"commit_protocol"),": The commit protocol for the transaction"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"timeout_height"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"timeout_timestamp"),": Specify the timeout for the transaction. The transaction will not be executed if the timeout is exceeded")),(0,o.kt)("p",null,"A Contract Transaction consists of the following elements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cross_chain_channel"),": The IBC channel between the initiator chain and the chain where the contract to be executed exists"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"signers"),": An array of ",(0,o.kt)("inlineCode",{parentName:"li"},"Accounts")," that need to be authenticated"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"callInfo"),": Call information including contract identifier, function name, and arguments. The format is ",(0,o.kt)("a",{parentName:"li",href:"/cross-docs/architecture/overview#contract-module"},"Contract Module")," specification"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"return_value"),": The return value expected from the execution of this contract (optional)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"links"),": Optional results of other contract calls that will be referenced when this contract is executed. See the ",(0,o.kt)("a",{parentName:"li",href:"#link"},"Link")," section for details")),(0,o.kt)("p",null,"When a ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgInitiateTx")," is submitted, it is processed by the ",(0,o.kt)("a",{parentName:"p",href:"/cross-docs/architecture/overview"},"Tx Initiator"),". The Tx Initiator then does the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Generate a TxID from the ",(0,o.kt)("inlineCode",{parentName:"li"},"MsgInitiateTx"),", verifies that it has not been submitted, and saves the TxID and the ",(0,o.kt)("inlineCode",{parentName:"li"},"MsgInitiateTx")),(0,o.kt)("li",{parentName:"ul"},"Check if ",(0,o.kt)("inlineCode",{parentName:"li"},"commit_protocol")," is supported by the initiator chain."),(0,o.kt)("li",{parentName:"ul"},"Ensure that ",(0,o.kt)("inlineCode",{parentName:"li"},"timeout_height")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"timeout_timestamp")," have not passed")),(0,o.kt)("p",null,"After these processes, ",(0,o.kt)("a",{parentName:"p",href:"#link"},"Link processing")," is performed."),(0,o.kt)("h2",{id:"link"},"Link"),(0,o.kt)("p",null,"Link is functionality to associate contract transactions that make ",(0,o.kt)("a",{parentName:"p",href:"/cross-docs/architecture/smart-contract"},"cross-chain calls"),". The initiator chain resolves each link to the corresponding result of the call using Linker when the ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgInitiateTx")," is submitted."),(0,o.kt)("p",null,"The following points should be considered when calling cross-chain contract functions:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Each contract function may be executed in parallel on each chain"),(0,o.kt)("li",{parentName:"ol"},"The execution of an external contract function must be atomic to the execution of its caller function"),(0,o.kt)("li",{parentName:"ol"},"the calling function can reference the return value from the execution of the external contract function")),(0,o.kt)("p",null,"Point 1. is guaranteed to be serializable by the locking mechanism in ",(0,o.kt)("a",{parentName:"p",href:"/cross-docs/architecture/state-store"},"State store"),", and point 2. is guaranteed by ",(0,o.kt)("a",{parentName:"p",href:"/cross-docs/architecture/atomic-commit-protocol"},"Atomic commit protocol"),". Link is a functionality to realize point 3. and the submitter of a transaction can associate it by specifying the chain to be referred to as ",(0,o.kt)("inlineCode",{parentName:"p"},"links")," in a ",(0,o.kt)("inlineCode",{parentName:"p"},"ContractTransaction")," that performs a cross-chain call. Note that Link is represented as the index of the referenced ",(0,o.kt)("inlineCode",{parentName:"p"},"ContractTransaction")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"contract_transactions"),"."),(0,o.kt)("p",null,"The Contract Transaction (calleeTx) pointed to by Link and the Contract Transaction (callerTx) referring to Link are processed as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The Linker generates a ",(0,o.kt)("inlineCode",{parentName:"li"},"CallResult")," whose key is composed of ",(0,o.kt)("inlineCode",{parentName:"li"},"call_info")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"signers")," of the calleeTx and whose value is ",(0,o.kt)("inlineCode",{parentName:"li"},"return_value")),(0,o.kt)("li",{parentName:"ol"},"The Linker resolves the ",(0,o.kt)("inlineCode",{parentName:"li"},"cross_chain_channel")," of the calleeTx to an IBC channel available to the caller. Then, it sets the resolved to the ",(0,o.kt)("inlineCode",{parentName:"li"},"CallResult")),(0,o.kt)("li",{parentName:"ol"},"The TxInitiator generates a ",(0,o.kt)("inlineCode",{parentName:"li"},"ResolvedContractTransaction")," from the callerTx's ",(0,o.kt)("inlineCode",{parentName:"li"},"ContractTransaction")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"CallResult"),". The definition of ",(0,o.kt)("inlineCode",{parentName:"li"},"ResolvedContractTransaction")," is as follows")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},"message ResolvedContractTransaction {\n  google.protobuf.Any cross_chain_channel = 1;\n  repeated cross.core.auth.Account signers = 2;\n  bytes call_info = 3;\n  ReturnValue return_value = 4;\n  repeated google.protobuf.Any call_results = 5; // List of CallResult\n}\n")),(0,o.kt)("p",null,"After resolving the link, the TxInitiator performs the ",(0,o.kt)("a",{parentName:"p",href:"#authentication"},"authentication process")," of the Transaction."),(0,o.kt)("h2",{id:"authentication"},"Authentication"),(0,o.kt)("p",null,"Transaction authentication is performed by the ",(0,o.kt)("a",{parentName:"p",href:"/cross-docs/architecture/overview#authenticator"},"Authenticator"),". The Authenticator provides authentication methods for the initiator chain and other chains connected by the IBC channel."),(0,o.kt)("p",null,"Authentication of a transaction is performed by the accounts specified in ",(0,o.kt)("inlineCode",{parentName:"p"},"signers")," of each contract transaction in ",(0,o.kt)("inlineCode",{parentName:"p"},"contract_transactions"),". The execution is blocked until the authentication is completed."),(0,o.kt)("p",null,"The authentication must satisfy each account's method specified in ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthType"),". A corresponding Msg, where the target TxID is set, is defined for each authentication method, and authorization is possible by satisfying the specified one."),(0,o.kt)("p",null,"Currently, ",(0,o.kt)("inlineCode",{parentName:"p"},"SignTx"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"IBCSignTx"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtSignTx")," are supported as authentication methods. The definitions of each method and their corresponding Msg are described below."),(0,o.kt)("h3",{id:"signtx"},"SignTx"),(0,o.kt)("p",null,"SignTx is a method that uses the authentication method of the chain in which the transaction is submitted. It can authenticate accounts with ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthMode")," specified as ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTH_MODE_LOCAL"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},"message MsgSignTx {\n  bytes txID = 1;\n  repeated bytes signers = 2; // List of Account IDs\n}\n")),(0,o.kt)("h3",{id:"ibcsigntx"},"IBCSignTx"),(0,o.kt)("p",null,"IBCSignTx is a method that uses the authentication method of the chain connected by the IBC channel to the chain where the transaction was submitted. It can authenticate accounts whose ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthMode")," are specified by ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTH_MODE_CHANNEL"),". Note that the accounts should have the information of the IBC channel to allow authentication as ",(0,o.kt)("inlineCode",{parentName:"p"},"option"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},"message MsgIBCSignTx {\n  google.protobuf.Any cross_chain_channel = 1;\n  bytes txID = 2;\n  repeated bytes signers = 3; // List of Account IDs\n  ibc.core.client.v1.Height timeout_height = 4;\n  uint64 timeout_timestamp = 5;\n}\n")),(0,o.kt)("h3",{id:"extsigntx"},"ExtSignTx"),(0,o.kt)("p",null,"ExtSignTx is a method that performs authentication according to a developer-defined authentication formula. It can authenticate accounts whose ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthMode")," are specified as ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTH_MODE_EXTENSION"),"."),(0,o.kt)("p",null,"The corresponding account has to hold proto.Message that implements AuthExtensionVerifier as ",(0,o.kt)("inlineCode",{parentName:"p"},"option"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},"message MsgExtSignTx {\n  bytes txID = 1;\n  repeated Account signers = 2;\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type AuthExtensionVerifier interface {\n    proto.Message\n    Verify(ctx sdk.Context, signer Account, signature signing.SignatureV2, tx sdk.Tx) error\n}\n")),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/datachainlab/cross/blob/v0.2.0/simapp/samplemod/types/auth.go"},"here")," for an example of such an extended authentication implementation."),(0,o.kt)("h2",{id:"transaction-execution"},"Transaction Execution"),(0,o.kt)("p",null,"After all authentication of the transaction is completed, ",(0,o.kt)("inlineCode",{parentName:"p"},"Tx Runner")," starts the flow of Atomic Commit according to the ",(0,o.kt)("inlineCode",{parentName:"p"},"commit_protocol"),". Each step of the flow sends a packet including the ",(0,o.kt)("inlineCode",{parentName:"p"},"ResolvedContractTransaction")," corresponding to each chain; For more information on the different types of commit flows and the details of each, see ",(0,o.kt)("a",{parentName:"p",href:"/cross-docs/architecture/atomic-commit-protocol"},"the Atomic commit protocol chapter"),"."),(0,o.kt)("p",null,"On each chain, a contract is processed as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Process a ",(0,o.kt)("inlineCode",{parentName:"li"},"ResolvedContractTransaction")," and returns it to ",(0,o.kt)("a",{parentName:"li",href:"/cross-docs/architecture/overview#contract-module"},"Contract Module")),(0,o.kt)("li",{parentName:"ul"},"If the contract contains cross-chain calls, verify that the arguments ",(0,o.kt)("inlineCode",{parentName:"li"},"ChannelInfo")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"ContractCallInfo")," of the ",(0,o.kt)("inlineCode",{parentName:"li"},"Call")," match the values of ",(0,o.kt)("inlineCode",{parentName:"li"},"CallResult")," of the corresponding ",(0,o.kt)("inlineCode",{parentName:"li"},"ResolvedContractTransaction")),(0,o.kt)("li",{parentName:"ul"},"After the contract is executed, call the Contract Manager's Precommit or CommitImmediately depending on the commit flow to save the status")),(0,o.kt)("p",null,"Regardless of the type of Commit flow, it is guaranteed that the update will only be committed if all Contract Transactions included in ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgInitiateTx")," are successfully executed, and if any of them fail, all Contract Transactions will be aborted."))}u.isMDXComponent=!0}}]);