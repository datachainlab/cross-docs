"use strict";(self.webpackChunkcross_docs=self.webpackChunkcross_docs||[]).push([[994],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=a.createContext({}),l=function(e){var t=a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(r),h=n,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||o;return r?a.createElement(m,i(i({ref:t},p),{},{components:r})):a.createElement(m,i({ref:t},p))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:n,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},5930:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=r(7462),n=(r(7294),r(3905));const o={sidebar_position:5,id:"state-store"},i="State store",s={unversionedId:"docs/architecture/state-store",id:"docs/architecture/state-store",title:"State store",description:"State store is an abstract KVS, or key-value store, class that persists the state of smart contracts on each chain. It supports the following elements:",source:"@site/docs/01-docs/03-architecture/05-state-store.md",sourceDirName:"01-docs/03-architecture",slug:"/docs/architecture/state-store",permalink:"/cross-docs/docs/architecture/state-store",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,id:"state-store"},sidebar:"tutorialSidebar",previous:{title:"Atomic commit protocol",permalink:"/cross-docs/docs/architecture/atomic-commit-protocol"},next:{title:"Overview",permalink:"/cross-docs/tutorial/overview"}},c={},l=[{value:"Lock Store",id:"lock-store",level:2},{value:"CDT(Conflict-free Data Types) Store",id:"cdtconflict-free-data-types-store",level:2}],p={toc:l},u="wrapper";function d(e){let{components:t,...r}=e;return(0,n.kt)(u,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"state-store"},"State store"),(0,n.kt)("p",null,"State store is an abstract KVS, or key-value store, class that persists the state of smart contracts on each chain. It supports the following elements:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Saving operations that change state"),(0,n.kt)("li",{parentName:"ol"},"Applying or discarding saved changes"),(0,n.kt)("li",{parentName:"ol"},"Locking mechanism for state access")),(0,n.kt)("p",null,"In general, executing contract functions sequentially in a single blockchain can reflect the changes in the store after each update operation. However, the state of contracts in chains needs to be updated atomically in a cross-chain application. If any contracts in one chain fail, the execution of all other related contracts must be interrupted. Therefore, the State store supports (1) the storage of state change operations and (2) the application and destruction of stored changes."),(0,n.kt)("p",null,"In addition, cross-chain transactions are executed cooperatively among blockchains, which means that they are divided into multiple transactions within a given chain. Therefore, there can be transactions operating in parallel in the same state. Cross Framework introduces the locking mechanism in (3) to guarantee the ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Serializability"},"serializability")," of transactions. The following describes a state store implementation that supports the currently provided two types of locking mechanisms."),(0,n.kt)("h2",{id:"lock-store"},"Lock Store"),(0,n.kt)("p",null,"Lock Store is a store that provides simple APIs such as Get, Set, etc., to obtain Read-Write lock."),(0,n.kt)("p",null,"The following operations are supported:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Get(K): Returns the value corresponding to the Key specified by ",(0,n.kt)("inlineCode",{parentName:"li"},"K")),(0,n.kt)("li",{parentName:"ul"},"Set(K,V): Set the value specified by ",(0,n.kt)("inlineCode",{parentName:"li"},"V")," to the key specified by ",(0,n.kt)("inlineCode",{parentName:"li"},"K")),(0,n.kt)("li",{parentName:"ul"},"Delete(K): Deletes a Key and its corresponding Value specified by ",(0,n.kt)("inlineCode",{parentName:"li"},"K"))),(0,n.kt)("p",null,"The store also acquires the following locks for each operation."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"State store operations"),(0,n.kt)("th",{parentName:"tr",align:null},"locks to be acquired"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Get(K)"),(0,n.kt)("td",{parentName:"tr",align:null},"Shared lock on K")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Set(K, V)"),(0,n.kt)("td",{parentName:"tr",align:null},"Exclusive lock on K")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Delete(K)"),(0,n.kt)("td",{parentName:"tr",align:null},"Exclusive lock to K")))),(0,n.kt)("h2",{id:"cdtconflict-free-data-types-store"},"CDT(Conflict-free Data Types) Store"),(0,n.kt)("p",null,"CDT Store is a store that implements a data structure called ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/datachainlab/cross-cdt"},"CDT")," that allows concurrent operations under certain conditions."),(0,n.kt)("p",null,"CDT defines multiple data types and currently supports Integer, Grow-only Set; Integer supports Add, Sub, and Compare functions, which can be used to implement ERC20 with concurrent operations. For more information, check here: ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/datachainlab/cross-cdt"},"https://github.com/datachainlab/cross-cdt")))}d.isMDXComponent=!0}}]);